# Dialyzer, ETC, and Gradualizer 2

```elixir
Mix.install([
  {:csv, "~> 2.4"},
  {:httpotion, "~> 3.1.0"},
  {:kino_vega_lite, "~> 0.1.1"}
])
```

## Let's get the test data

```elixir
tsv_url =
  "https://gist.githubusercontent.com/erszcz/4d43a77464c87a514e71eecf2811af63/raw/bf8d18cfd236e82bba794c169b57f1f284475ddd/check.2022-07-13_170833.tsv"

response = HTTPotion.get(tsv_url)
```

```elixir
tab = 0x09

{:ok, stream} =
  response.body
  |> StringIO.open()

tsv =
  stream
  |> IO.binstream(:line)
  |> CSV.decode!(separator: tab)
  |> Enum.into([])
  |> Enum.drop(1)
```

```elixir
headers = [
  :type,
  :dialyzer,
  :etc,
  :gradualizer,
  :dialyzer_seconds,
  :etc_seconds,
  :gradualizer_seconds,
  :file
]

# series by header
by_header =
  tsv
  |> Enum.zip()
  |> Enum.map(&Tuple.to_list/1)

by_header = Enum.zip(headers, by_header) |> Enum.into(%{})
```

```elixir
by_test_type = tsv |> Enum.group_by(&List.first/1)

tool_to_index = %{
  dialyzer: 1,
  etc: 2,
  gradualizer: 3
}

extract_tool = fn row, tool ->
  case Enum.at(row, tool_to_index[tool]) do
    "ok" -> [tool |> to_string() |> String.capitalize()]
    _ -> []
  end
end

map_test_type_series_to_tools = fn series ->
  series
  |> Enum.flat_map(fn row ->
    [
      ["All tests"],
      extract_tool.(row, :dialyzer),
      extract_tool.(row, :etc),
      extract_tool.(row, :gradualizer)
    ]
    |> Enum.concat()
  end)
end

by_test_type = %{
  "known_problems_should_fail" =>
    map_test_type_series_to_tools.(by_test_type["known_problems_should_fail"]),
  "known_problems_should_pass" =>
    map_test_type_series_to_tools.(by_test_type["known_problems_should_pass"]),
  "should_fail" => map_test_type_series_to_tools.(by_test_type["should_fail"]),
  "should_pass" => map_test_type_series_to_tools.(by_test_type["should_pass"])
}
```

```elixir
# Sanity check!
[n_should_pass, n_known_problems_should_pass, n_should_fail, n_known_problems_should_fail] = [
  by_test_type["should_pass"] |> Enum.filter(fn e -> e == "All tests" end) |> length,
  by_test_type["known_problems_should_pass"]
  |> Enum.filter(fn e -> e == "All tests" end)
  |> length,
  by_test_type["should_fail"] |> Enum.filter(fn e -> e == "All tests" end) |> length,
  by_test_type["known_problems_should_fail"]
  |> Enum.filter(fn e -> e == "All tests" end)
  |> length
]

[103, 16, 86, 11] = [
  n_should_pass,
  n_known_problems_should_pass,
  n_should_fail,
  n_known_problems_should_fail
]
```

## Analysis and comparison

### Tests that should pass

This chart depicts the number of tests which should pass, i.e. should type check. After all, **we do not want our type checkers to raise warnings about valid code.**

Given we're considering code that's assumed to be valid, none of the type checkers should report warnings here. Cross-checking these tests with different type checkers allows to find bugs in tests or the type checkers themselves.

Dialyzer reports only a few errors. Gradualizer, as expected, reports none. ETC fares quite poorly, passing only 1/3 of the tests, which suggests it might not cover the complete Erlang syntax.

Higher is better.

```elixir
{should_pass_xs, should_pass_ys} =
  by_test_type["should_pass"]
  |> Enum.group_by(fn e -> e end)
  |> Enum.map(fn {type, v} -> {type, length(v)} end)
  |> Enum.unzip()

should_pass = %{
  "Tool" => should_pass_xs,
  "Tests passed" => should_pass_ys
}
```

<!-- livebook:{"attrs":{"chart_title":null,"height":300,"layers":[{"chart_type":"bar","color_field":"Tool","color_field_aggregate":null,"color_field_type":null,"data_variable":"should_pass","x_field":"Tool","x_field_aggregate":null,"x_field_type":null,"y_field":"Tests passed","y_field_aggregate":null,"y_field_type":"quantitative"}],"vl_alias":"Elixir.VegaLite","width":300},"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 300, height: 300)
|> VegaLite.data_from_values(should_pass, only: ["Tool", "Tests passed"])
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "Tool")
|> VegaLite.encode_field(:y, "Tests passed", type: :quantitative)
|> VegaLite.encode_field(:color, "Tool")
```

### Known problems: tests that should pass, but do not

This chart depicts the number of tests which should pass, i.e. should type check, yet raise Gradualizer errors. In other words, __these are the false positives - invalid or misleading reports about non-issues.__

Dialyzer reports only a single false positive and is a clear winner here! This confirms the slogan that _Dialyzer is never wrong_.
ETC reports some of the errors, but not all of them.
Gradualizer, as expected, reports errors for all of the tests.

Lower is better.

```elixir
{known_problems_should_pass_xs, known_problems_should_pass_ys} =
  by_test_type["known_problems_should_pass"]
  |> Enum.group_by(fn e -> e end)
  |> Enum.map(fn {type, v} -> {type, n_known_problems_should_pass - length(v)} end)
  |> Enum.unzip()

known_problems_should_pass = %{
  "Tool" => known_problems_should_pass_xs ++ ["Gradualizer"],
  "Errors detected" =>
    [n_known_problems_should_pass] ++
      Enum.drop(known_problems_should_pass_ys, 1) ++ [n_known_problems_should_pass]
}
```

<!-- livebook:{"attrs":{"chart_title":null,"height":300,"layers":[{"chart_type":"bar","color_field":"Tool","color_field_aggregate":null,"color_field_type":null,"data_variable":"known_problems_should_pass","x_field":"Tool","x_field_aggregate":null,"x_field_type":null,"y_field":"Errors detected","y_field_aggregate":null,"y_field_type":"quantitative"}],"vl_alias":"Elixir.VegaLite","width":300},"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 300, height: 300)
|> VegaLite.data_from_values(known_problems_should_pass, only: ["Tool", "Errors detected"])
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "Tool")
|> VegaLite.encode_field(:y, "Errors detected", type: :quantitative)
|> VegaLite.encode_field(:color, "Tool")
```

### Tests which should fail

This chart depicts the number of tests which should fail, i.e. should not type check. **These tests check that the warnings we want to see in our buggy code are actually generated.**

Dialyzer seems to be somewhat permissive. ETC reports the majority of errors. Gradualizer properly reports all the errors.

Higher is better.

```elixir
{should_fail_xs, should_fail_ys} =
  by_test_type["should_fail"]
  |> Enum.group_by(fn e -> e end)
  |> Enum.map(fn {type, v} -> {type, n_should_fail - length(v)} end)
  |> Enum.unzip()

should_fail = %{
  "Tool" => should_fail_xs ++ ["Gradualizer"],
  "Errors detected" => [n_should_fail] ++ Enum.drop(should_fail_ys, 1) ++ [n_should_fail]
}
```

<!-- livebook:{"attrs":{"chart_title":null,"height":300,"layers":[{"chart_type":"bar","color_field":"Tool","color_field_aggregate":null,"color_field_type":null,"data_variable":"should_fail","x_field":"Tool","x_field_aggregate":null,"x_field_type":null,"y_field":"Errors detected","y_field_aggregate":null,"y_field_type":"quantitative"}],"vl_alias":"Elixir.VegaLite","width":300},"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 300, height: 300)
|> VegaLite.data_from_values(should_fail, only: ["Tool", "Errors detected"])
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "Tool")
|> VegaLite.encode_field(:y, "Errors detected", type: :quantitative)
|> VegaLite.encode_field(:color, "Tool")
```

### Known problems: tests that should fail, but do not

This chart depicts the number of tests which should fail, i.e. should not type check, but are known to type check with Gradualizer. In other words, **these are the errors that considered type checkers cannot find.** We have to rely on tests, code review, or other techniques to find them.

Dialyzer detects some of the errors in these examples, ETC seems to detect even more. Gradualizer doesn't detect any of them, but the examples are crafted against this type checker, so it's expected.

Higher is better.

```elixir
{known_problems_should_fail_xs, known_problems_should_fail_ys} =
  by_test_type["known_problems_should_fail"]
  |> Enum.group_by(fn e -> e end)
  |> Enum.map(fn {type, v} -> {type, n_known_problems_should_fail - length(v)} end)
  |> Enum.unzip()

known_problems_should_fail = %{
  "Tool" => known_problems_should_fail_xs,
  "Errors detected" =>
    [n_known_problems_should_fail] ++ Enum.drop(known_problems_should_fail_ys, 1)
}
```

<!-- livebook:{"attrs":{"chart_title":null,"height":300,"layers":[{"chart_type":"bar","color_field":"Tool","color_field_aggregate":null,"color_field_type":null,"data_variable":"known_problems_should_fail","x_field":"Tool","x_field_aggregate":null,"x_field_type":null,"y_field":"Errors detected","y_field_aggregate":null,"y_field_type":"quantitative"}],"vl_alias":"Elixir.VegaLite","width":300},"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 300, height: 300)
|> VegaLite.data_from_values(known_problems_should_fail, only: ["Tool", "Errors detected"])
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "Tool")
|> VegaLite.encode_field(:y, "Errors detected", type: :quantitative)
|> VegaLite.encode_field(:color, "Tool")
```

## Some examples

#### should_pass/andalso_any.erl

Described at https://github.com/josefs/Gradualizer/pull/429#discussion_r920465166.
Seems to be a soundness error in Gradualizer!

<!-- livebook:{"break_markdown":true} -->

#### should_pass/binary_exhaustiveness_checking.erl

Dialyzer warns about an unexported function.
Gradualizer type checks functions no matter if they're exported or not.
Dialyzer warning goes away after we export `l/1`.

<!-- livebook:{"break_markdown":true} -->

#### should_pass/flow.erl

Dialyzer sees no other local call sites than `bar(apa)`,
therefore infers the argument type of `bar/1` to be just `apa`,
which in turn means that the second clause of `bar/1` is redudant.
This leads to a valid warning.

Adding `-export([bar/1])` at the top makes Dialyzer accept the code.

Gradualizer does not warn either with or without the extra `export` attribute.

<!-- livebook:{"break_markdown":true} -->

#### should_pass/iodata.erl

Dialyzer detects an improper list creation, which is not an error for Gradualizer (but maybe it should?) - this time even `--infer` to Gradualizer doesn't change the outcome.

<!-- livebook:{"break_markdown":true} -->

#### should_pass/named_fun_infer_pass.erl

Dialyzer infers that 0 in `F(Atoms, 0)` is not a list of integers.
Gradualizer does not.

<!-- livebook:{"break_markdown":true} -->

#### should_pass/named_fun_pass.erl

Dialyzer fails due to arity mismatch.
Gradualizer does so only with `--infer`. Dialyzer is inferring more aggressively.

<!-- livebook:{"break_markdown":true} -->

#### should_pass/negate_none.erl

Dialyzer returns "no local return" from `foo/0`.
Gradualizer is silent.

<!-- livebook:{"break_markdown":true} -->

#### should_pass/records.erl

Dialyzer reported unexported local functions which would never be called.
Gradualizer did not, but the Erlang compiler would, so it's not a big deal.

<!-- livebook:{"break_markdown":true} -->

#### should_pass/return_fun.erl

One of the few cases in `should_pass` tests where Dialyzer actually detects errors,
whereas Gradualizer does not.

```erlang
-spec return_fun_no_spec() -> integer().
return_fun_no_spec() -> fun no_spec/0.

no_spec() -> ok.
```

Dialyzer:

```
return_fun.erl:28:2: Invalid type specification for function return_fun:return_fun_no_spec/0.
The success typing is
          () -> fun(() -> 'ok')
```

ETC:

```
test/should_pass/return_fun.erl: error in parse transform
```

Gradualizer: no error!

Let's remember that by default Gradualizer doesn't infer types of functions with no specs.

Gradualizer with `--infer`:

```
return_fun.erl:29:25: The fun expression is expected to have type integer()
but it has type fun(() -> any())
```

Dialyzer seems to infer more types by default.
However, if we ask Gradualizer to try a bit harder, it's even with Dialyzer on this one.
The file is too complex for ETC to process - it crashes :(

<!-- livebook:{"break_markdown":true} -->

#### should_pass/scope.erl

Another one of the few cases in `should_pass` tests where Dialyzer detects errors,
but Gradualizer does not.

```
f(X) ->
    case g(X) of
        true -> A = 5,
                B = 7;
        false -> B = 6
    end,
    B.

g(_X) ->
    true.
```

Dialyzer:

```
scope.erl:9:9: The pattern 'false' can never match the type 'true'
```

ETC: ok

Gradualizer: ok

Another example showing that Dialyzer type inference is quite aggressive and quite accurate!
It knows that `g/1` can never return anything else than `true`,
so the latter clause of the case expression enclosing the `g(X)` call is redundant.
In this case the entire case expression is redundant and `B` will always be 7.

It's interesting to note that Gradualizer cannot detect the error even if we modify the code as follows:

TODO: create a bug report about it!

```
-spec f(any()) -> atom().
f(X) ->
    case g(X) of
        true -> A = 5,
                B = 7;
        false -> B = 6
    end,
    B.

-spec g(any()) -> true.
g(_X) ->
    true.
```

<!-- livebook:{"break_markdown":true} -->

#### known_problems/should_pass/list_tail.erl

The only false positive raised by Dialyzer, which is known for _never being wrong_. Is it a Dialyzer bug?

```erlang
atom_tail() ->
    [ 1 | list_to_atom("banana") ].
```

Dialyzer:

```
list_tail.erl:7:5: Cons will produce an improper list since its 2nd argument is atom()
```

ETC:

```
unify failed with types [integer] :=: atom
```

Gradualizer:

```
list_tail.erl:7: The expression of type atom() is not a list type
```

Apparently, all the type checkers agree. It definitely is not a Dialyzer bug. Maybe the test should be moved from `known_problems/should_pass` to `should_fail`?
